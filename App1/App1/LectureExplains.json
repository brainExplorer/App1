[
  {
    "topic": "Asynchronous",
    "explains": "Asynchronous meaning is event or another thing doesn't happening or complete at the same speed or time. We apply async and Task keyword to function and we add await keyword to event or another releated things.\n\tstatic void Main(string[] args)\n\t{\n\t\tMethod1();\n\t\tMethod2();\n\t\tConsole.ReadKey();\n\t}\n\tpublic static async Task Method1()\n\t{\n\t\tawait Task.Run(() =>\n\t\t{\n\t\t\tfor (int i = 0; i < 10; i++)\n\t\t\t{\n\t\t\t\tTask.Delay(100).Wait();\n\t\t\t}\n\t\t});\n\t}\n\tpublic static void Method2()\n\t{\n\t\tfor (int i = 0; i < 5; i++)\n\t\t{\n\t\t\tTask.Delay(100).Wait();\n\t\t}\n\t}"
  },
  {
    "topic": "Delegates",
    "explains": "C# delegates are such as pointers to functions, in C or C++.A delegate is a reference type variable that holds the reference to a method. The reference can be changed at runtime.\nDelegates are especially used for implementing events and the call-back methods.\nAll delegates are implicitly derived from the System.Delegate class.Delegates have the following properties:\nDelegates are similar to C++ function pointers, but delegates are fully object-oriented, and unlike C++ pointers to member functions, delegates encapsulate both an object instance and a method.\nDelegates allow methods to be passed as parameters.\nDelegates can be used to define callback methods.\nDelegates can be chained together; for example, multiple methods can be called on a single event.\nMethods don't have to match the delegate type exactly. For more information, see Using Variance in Delegates.\nLambda expressions are a more concise way of writing inline code blocks. It occours 3 pieces.\n 1)Declare a delegate and delegate completly contains same objects with target function(s)\n 2)Set target method or assign to function or set lambda expression.\n 3)Target method\n\npublic delegate void DelegateFunction(int temp);\n DelegateFunction delgF = myFunc;\npublic void myFunc(int t)\n{\n  Console.WriteLine(${\"t*t*t\"});\n}"
  },
  {
    "topic": "Design Patterns",
    "explains": "Design Patterns have mainly divided in three.These are Creational, Structural, Behavioral. 1)Creational design patterns provide various object creation mechanisms, which increase flexibility and reuse of existing code.\n1.a)Singleton is a creational design pattern that lets you ensure that a class has only one instance, while providing a global access point to this instance.\n1.b)Abstract Factory is a creational design pattern that lets you produce families of related objects without specifying their concrete classes.\n1.c)Builder is a creational design pattern that lets you construct complex objects step by step. The pattern allows you to produce different types and representations of an object using the same construction code.\n 2)Structural design patterns explain how to assemble objects and classes into larger structures, while keeping these structures flexible and efficient.\n2.a)Adapter is a structural design pattern that allows objects with incompatible interfaces to collaborate.\n2.b)Decorator is a structural design pattern that lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.\n2.c)Facade is a structural design pattern that provides a simplified interface to a library, a framework, or any other complex set of classes.\n3)Behavioral design patterns are concerned with algorithms and the assignment of responsibilities between objects.\n3.a)Observer is a behavioral design pattern that lets you define a subscription mechanism to notify multiple objects about any events that happen to the object theyâ€™re observing.\n3.b)Strategy is a behavioral design pattern that lets you define a family of algorithms, put each of them into a separate class, and make their objects interchangeable.\n3.c)Chain of Responsibility is a behavioral design pattern that lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.\n"
  },
  {
    "topic": "Dynamic",
    "explains": "This is a static type, but dynamic types pass the static type checking.\nWe assume that dynamic object has a support any operation on at compile time.\nYou don't care where was value come from.\nBut it give an error at the runtime.\n\n\tdynamic d1 = 7;\n\tdynamic d2 = \"Be happy and save your health.\";\n\tdynamic d3 = DateTime.Today.Day;\n\tdynamic d4 = Process.GetCurrentProcess().ProcessName;\n\tint v1 = d1 + d3;\n\tConsole.WriteLine($\"Todays date is {DateTime.Today.Date}, date sum with int value result: {v1} and process name: {d4}\");"
  },
  {
    "topic": "Event",
    "explains": "It is used to declare an events in a releated class.\n\n\n/*Program.cs*/\n\tpublic static void Main()\n\t\t{\n\t\tEventClass1 eventClass = new EventClass1();\n\t\teventClass.eventHandler += myFunc;\n\t\teventClass.runMe();\n\t\teventClass.eventHandler -= myFunc;\n\t}\n\tpublic static void myFunc()\n\t{\n\t\tConsole.WriteLine(\"Just sample to event\");\n\t}\n/*EventClass.cs*/\n\tpublic delegate void EventHandler();\n\tpublic event EventHandler eventHandler;\n\tpublic void runMe()\n\t{\n\t\tRan();\n\t}\n\tprotected virtual void Ran()\n\t{\n\t\teventHandler?.Invoke();\n\t}\n\n Note : Virtual keyword provides derived classes to override the event behavior."
  },
  {
    "topic": "Exception Handling",
    "explains": "An exception is a problem that arises during the execution of a program.\n try:It is used to for run code samples.\n catch: It catches the any exception.\n finally:It is used to execute a given set of statements, whether an exception is thrown or not thrown.\n throw:It throws exception in any error stiation.\n\n\tstring myString = \"true\";\n\t/* determines whether 2 instances is same. So it returns bool value.*/\n\tdynamic f = ProcessThread.ReferenceEquals(Thread.CurrentThread, Thread.CurrentThread);\n\ttry\n\t{\n\t\tConsole.WriteLine($\"Is it true {f == myString}\");}\n\tcatch (Exception e)\n\t{\n\t\tthrow new Exception(myString, e);\n\t}\n\nfinally\n\t{\n\t\tConsole.WriteLine($\"Current thread : {Thread.CurrentThread}.\");\n\t}"
  },
  {
    "topic": "Extensions",
    "explains": "Methods can be called without creating a new type or changing a type. They are static methods.LINQ is a good example of this.\n\n// Define three classes that implement IMyInterface, and then use them to test\n// the extension methods.\nnamespace ExtensionMethodsDemo1\n{\n\tusing System;\n\t\tusing Extensions;\n\tusing DefineIMyInterface;\n\tclass A : IMyInterface\n\t{\n\t\tpublic void MethodB() { Console.WriteLine(\"A.MethodB()\"); }\n\t}\n\tclass B : IMyInterface\n\t{\n\t\tpublic void MethodB() { Console.WriteLine(\"B.MethodB()\"); }\n\t\tpublic void MethodA(int i) { Console.WriteLine(\"B.MethodA(int i)\"); }\n\t}\nclass C : IMyInterface\n\t{\n\tpublic void MethodB() { Console.WriteLine(\"C.MethodB()\"); }\n\tpublic void MethodA(object obj)\n\t{\n\t\tConsole.WriteLine(\"C.MethodA(object obj)\");\n\t}\n\t}\nclass ExtMethodDemo\n{\n\tstatic void Main(string[] args)\n\t{\n\t\t// Declare an instance of class A, class B, and class C.\n\t\tA a = new A();\n\t\t B b = new B();\n\t\tC c = new C();\n\n\t\t// For a, b, and c, call the following methods:\n\t\t//      -- MethodA with an int argument\n\t\t//      -- MethodA with a string argument\n\t\t//      -- MethodB with no argument.\n\t\t// A contains no MethodA, so each call to MethodA resolves to\n\t\t// the extension method that has a matching signature.\n\t\ta.MethodA(1);           // Extension.MethodA(IMyInterface, int)\n\t\ta.MethodA(\"hello\");     // Extension.MethodA(IMyInterface, string)\n\n\t\t// A has a method that matches the signature of the following call\n\t\t// to MethodB.\n\t\ta.MethodB();            // A.MethodB()\n\n\t\t// B has methods that match the signatures of the following\n\t\t// method calls.\n\t\tb.MethodA(1);           // B.MethodA(int)\n\t\tb.MethodB();            // B.MethodB()\n\n\t\t// B has no matching method for the following call, but\n\t\t// class Extension does.\n\t\tb.MethodA(\"hello\");     // Extension.MethodA(IMyInterface, string)\n\n\t\t// C contains an instance method that matches each of the following\n\t\t// method calls.\n\t\tc.MethodA(1);           // C.MethodA(object)\n\t\tc.MethodA(\"hello\");     // C.MethodA(object)\n\t\tc.MethodB();            // C.MethodB()\n\t}\n\t}\n}\n/* Output:\n\tExtension.MethodA(this IMyInterface myInterface, int i)\n\tExtension.MethodA(this IMyInterface myInterface, string s)\n\tA.MethodB()\n\tB.MethodA(int i)\n\tB.MethodB()\n\tExtension.MethodA(this IMyInterface myInterface, string s)\n\tC.MethodA(object obj)\n\tC.MethodA(object obj)\n\tC.MethodB()\n*/"
  },
  {
    "topic": "Generic",
    "explains": "\nGenerics allow you to define the specification of the data type of programming elements in a class or a method, until it is actually used in the program. In other words, generics allow you to write a class or method that can work with any data type.\nYou write the specifications for the class or the method, with substitute parameters for data types. When the compiler encounters a constructor for the class or a function call for the method, it generates code to handle the specific data type\nFeatures of Generics\nGenerics is a technique that enriches your programs in the following ways.\nIt helps you to maximize code reuse, type safety, and performance.\nYou can create generic collection classes. The .NET Framework class library contains several new generic collection classes in the System.Collections.Generic namespace. You may use these generic collection classes instead of the collection classes in the System.Collections namespace.\nYou can create your own generic interfaces, classes, methods, events, and delegates.\nYou may create generic classes constrained to enable access to methods on particular data types.\nYou may get information on the types used in a generic data type at run-time by means of reflection.\nGeneric Delegates\nYou can define a generic delegate with type parameters.\n\nprivate static void StackPanelDelocker(object sender)\n{\n\tStackPanel s = sender as StackPanel;\n\tforeach (var item in FindVisualChildren<StackPanel>(s))\n\t{\n\t\titem.IsEnabled = true;\n\t}\n} \n /*Create Generates*/\n\nprivate static IEnumerable<T> FindVisualChildren<T>(DependencyObject depObj) where T : DependencyObject\n\t{\n\t\tif (depObj != null)\n\t\t{\n\t\t\tfor (int i = 0; i < VisualTreeHelper.GetChildrenCount(depObj); i++)\n\t\t\t{\n\t\t\t\tDependencyObject child = VisualTreeHelper.GetChild(depObj, i);\n\t\t\t\tif (child != null && child is T)\n\t\t\t\t{\n\t\t\t\t\tyield return (T)child;\n\t\t\t\t}\n\n\t\t\t\tforeach (T childOfChild in FindVisualChildren<T>(child))\n\t\t\t\t{\n\t\t\t\tyield return childOfChild;\n\t\t\t\t}\n\t\t\t}\n\t\t }\n\t }"
  },
  {
    "topic": "Inheritance",
    "explains": "Inherit fields and methods from one class to other class. \n\nDerived Class (child) - the class that inherits from another class\nBase Class (parent) - the class being inherited from\n\nReusability of classes are provided by inheritance.\nIf you use \"sealed\" keyword, it can't implemented to any class.using System;\npublic class HelloWorld\n{\n\tpublic static void Main(string[] args)\n\t{\n\t\tChild child = new Child();\n\t\tchild.baseName = \"Child class\";\n\t\tchild.runIt();\n\t}\n}\nclass Base\n{\n\t\tpublic string baseName;\n}\nclass Child : Base\n{\n\tpublic void runIt()\n\t{\n\t\tConsole.WriteLine($\"It name is {baseName}\");\n\t}\n}"
  },
  {
    "topic": "Lambda Expressions",
    "explains": "You use a lambda expression to create an anonymous function. Use the lambda declaration operator.\n\n=> to separate the lambda's parameter list from its body. \nTo create a lambda expression, you specify input parameters (if any) on the left side of thelambda\noperator and an expression or a statement block on the other side.\nAny lambda expression can be converted to a delegate type. The delegate type to which alambda \nexpression can be converted is defined by the types of its parameters and return value.\nprivate void spHard_MouseLeave(object sender, MouseEventArgs e) => StackPanelLocker(sender);"
  },
  {
    "topic": "Linq",
    "explains": "LINQ(language integrated query): Extends the language by adding linq query expressions.\nWhere it can be used:\n\tSeries\n\tEnumerable classes\n\tXML documents\n\tRelational databases\n\t3rd party data sources (OnAudience, Lotame, Eyeota, Oracle, Adsquare, Adobe, Acxiom,DataSift). \n\n Linq other usefull items:\nSelect, Where, SelectMany, Sum, Min, Max, Average, Aggregate, Join, GroupJoin, TakeWhile, Skip, SkipWhile, OfType, Concat, OrderBy, ThenBy, Reverse, GroupBy, Distinct, Union, Intersect, Except, SequenceEqual, First, FirstOrDefault, Last, LastOrDefault, Single, SingleOrDefault, ElementAt, Any, All, Contains, Count.\n\nAsEnumerable : Statically writes the collection as an Ienumerable<T>.\nAsQueryable : Statically writes the collection as IQueryable<T>.\nToArray : Creates a T[] array from the collection.\nToList : Creates a List<T> from the collection.\nToDictionary : Creates Dictionary<K, T> from collection, indexed by key.\nToLookup : Creates an indexed Lookup<K, T> from the collection with a key K.\nCast : Converts a non-generic IEnumerable collection to an IEnumerable<T> by converting each element to type T.\nOfType : Converts the non-generic Ienumerable collection to an Ienumerable<T>.\n        \nstring[] types = {\"Detroit Techno\", \"Acid Techno\", \"Dub Techno\", \"Hard Techno\" };\nstring[] artists = { \"Juan Atkins\", \" Kevin Saunderson\", \"Derrick May\" };\nvar linqQuery = from type in types.Concat(artists)\n\t\t\t\twhere type.Contains(\"D\")\n\t\t\t\tselect type;\nforeach(var item in linqQuery)\n{\n\tConsole.WriteLine(item);\n}"
  },
  {
    "topic": "Nullable",
    "explains": "\"A nullable value type T? represents all values of its underlying value type T and an additional null value(Microsoft definition).\"\n\nint? first = null;\nint? temp = first^8 ?? 0;\nif(temp.HasValue)\n{\n\tConsole.WriteLine($\"temp is {temp}\");  // output: temp is 0\n}"
  },
  {
    "topic": "Object Life Time",
    "explains": "\nIn .NET programming, an object is created with the new keyword and allocated on the managed heap. \nThe object is alive until the garbage collector finds out that the object is no longer reachable from a strong root reference via a path of strong references. \nEach program has a main method and an associated class as well as static classes that all might contain local variables, static members, or even events. \nThese static or local references are considered to be root references within your program.\nOrdinary .NET Framework references are known to be strong references.\nObject lifetime is determined by the path of strong references that point from a root reference to an object.\nSometime you do not change the lifetime of an object. So the .NET Framework have an additional class called WeakReference that allows you to implement a weak reference between objects.\nThis weak reference is ignored when determining the lifetime of an object.\nThe WeakEvent pattern has been used in the Windows Presentation Foundation (WPF) Data Binding implementation to prevent leakage due to data binding.\n(https://docs.microsoft.com/en-us/archive/msdn-magazine/2007/november/clr-inside-out-managing-object-lifetime)\n\n Some definition;\n\tMemory Leaks:Occurs when used event subscriptions are not freed from memory.\n\tLifetime Management Resources: Lifetime management works via reference counting in the COM. IUnknown::AddRef and IUnknown::Release are use in there. Thats mean counters change by developer. If counter equal to 0 then the object destroyed.\n\tReference countings are affect the performance. Loss of performance and inability to detect dead objects are the two main problems. If you have CLR(common language runtime)\n\tAdding a reference count has a huge performance impact. You use tlbimp.exe running in the background to generate an RCW(runtime callable wrapper) when there is a reference to the COM component in Visual Studio. Along with these AddRef is called after the component is created, Release is when the \n\tRCW is terminated. Dispose is called to ensure that the RCW is terminated.\n Garbage Collection And Finalization: When the run garbage colllector(GC) all other threads are paused and then GC analyzes memory for dead objects.\nFinalize method performs finalization, moslty form of cleanup.During object destruction, object being deallocated are some finalize work. \nFinalizers not recommend therefore due to difficulty in proper use and the complexity they add. You can use alternatively dispose."
  },
  {
    "topic": "Partial Classes",
    "explains": "Partial class usefull when working on large projects, spreading a class over separate files enables multiple programmers to work on it at the same time, working with automatically generated source, code can be added to theclass without having to recreate the source file. Visual Studio uses this approachwhen it creates Windows Forms, Web service wrapper code, and so on. You can create code that uses these classes without having to modify the file created byVisual Studio, source generators to generate additional functionality in a class.\n Partial class has restrictions.\nAll partial-type definitions meant to be parts of the same type must be modified with partial.\nThe partial modifier can only appear immediately before the keywords class,struct, orinterface.\nThe public, private, protected, internal, abstract, sealed, base class, new, modifier (nested parts) and generic constraints keywords on a partial-type definition are optional, but if present onone partial-type definition, cannot conflict with the keywords specified on anotherpartial definition for the same type."
  },
  {
    "topic": "Regular Expressions",
    "explains": "In C#, Regular Expression is a pattern which is used to parse and check whether the given input text is matching with the given pattern or not. In C#, Regular Expressions are generally termed as C# Regex. The .Net Framework provides a regular expression engine that allows the pattern matching.\n\nprivate static void catchTheSameWord(string text)\n{\n\tstring pattern = @\"\\b(?<word>\\w+)\\s+(\\k<word>)\\b\";\n\t//define a reg. exp. for repeated words\n\tRegex regex = new Regex(pattern, RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.Multiline);\n\tMatchCollection matchCollection = regex.Matches(text);\n\t// We didn't assigned as a 'var' type. If we did it, we couldn't call the Groups extension.\n\tforeach (Match item in matchCollection)\n\t{\n\t\t// It keeps a collection of single match.\n\t\tGroupCollection groupCollection = item.Groups;\n\t\t// 'word' referenced twice or multiple same words.\n\t\tConsole.WriteLine($\"'{groupCollection[\"word\"].Value}'s positions are {groupCollection[0].Index} and {groupCollection[1].Index}.\");\n\t}\n}\nprivate static void catchTheNumbers(string[] numbers)\n{\n\tstring pattern = @\"^-?[0-9][0-9,\\.]+$\";\n\tRegex rgx = new Regex(pattern);\n\tConsole.WriteLine(\"Matched items : \");\n\tforeach (string? item in numbers)\n\t{\n\t\tif (rgx.IsMatch(item))\n\t\t{\n\t\t\tConsole.WriteLine($\"{item}\");\n\t\t}\n\t}\n}\n}\n/*\n \\b : match boundary words like in \\b\\w+\\s\\w+\\b pattern.\n? : the previous element zero or one time\n \\k< word > :  Matches the value of a word expression.\n \\s+ : Matches one or more white-space character(s).\n() : it uses to subexpressions.\n*/"
  },
  {
    "topic": "Type Conversations",
    "explains": "Change data type to different type depending on rules.\nImplicit Casting(Automaticaly):\n char -> int -> long -> float -> double \n int intVar=2;\n double doublevar=intVar; \n\nExplicit Casting(manually):\n double -> float -> long -> int -> char\n double dVar=8.5;\n int myInt=(int)dVar;\nUser defined conversations:\n Implicit type casting: \nstatic public implicit operator <class>(<type> value) {\n\treturn new <class>() { <value> = value, <boolean> = false };\n}\n Explicit user defined type casting:\nstatic public explicit operator <type>(<class> <instance>){\n\treturn <instance>.<value>;\n}\nConversions with helper classes: byte[] array = new byte[4];\narray[0] = 1;\narray[1] = 64;\narray[2] = 0;\nint result1 = BitConverter.ToInt32(array, 0);\nString str = Convert.ToBase64String(array);\nstring[] values = { \"+13230\", \"-0\", \"1,390,146\", \"$190,235,421,127\"};\n int number = Int32.Parse(value);"
  }
]